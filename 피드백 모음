최단경로
일단 성공은 했는데....
-> 먼저 메모리 제한때문에 그래프를 인접 행렬 방식으로 저장하면 안된다.
-> 문제에서 주어진 메모리 제한을 잘 계산 하자
-> 인접리스트로 했는데 시간초과....
-> 다익스트라를 그.냥. 만들면 시간 복잡도가 N^2이 나온다
-> 우선순위 큐(==힙)을 만들어서 시간 복잡도를 N * logN으로 만들었다
-> 그래도 시간초과
-> 질문글을 보니 endl이 출력이 느리다고 한다..?
-> ios::sync_with_stdio(false); cin.tie(0); 이것도 추가하라고 한다..? 이게 뭘까
c에서 c++로 넘어와보니 STL이 상당히 강력하다
->먼저 Template 쓰는 법을 공부하자
-> priority queue가 STL로 있었는데 각 인자가 무엇을 뜻하는지 정확히 공부하자
-> vector, pair도 공부하자
시간복잡도를 고려해서 코드를 구현하자
-> 알고리즘의 최적 시간 복잡도를 미리 알고있자



알파벳
DFS에서 pop된 값에 대해서 방문표시를 해제하는 것을 잊지 말자
-> 재귀로 구현했는데 언제 pop을 하고 언제 함수를 return하는지 잘 살펴보자
답을 maxans로 출력하면서 초기값을 ans로 할당해주지 않은 이유는 뭘까..?
-> 매우 간단한 예제 1 1 이게 틀린답을 내놓았다
                    A
-> 답을 도출하는 변수를 잘 관찰해보자.

미로탐색
문제에서 원하는 값이 무엇인지 정확히 파악하자
-> 처음에 접근 했던 방식은 최단경로를 찾는 것이었다. 하지만 문제는 미로를 탈출할 때 이동해야하는 최소의 칸.수. 이다. 어느 위치의 블럭을 지났는지는 몰라도 된다.
현재 위치에서 이동가능한 길을 찾는 함수인 find를 좀 더 깔끔하게 할 수는 없을까?
-> ,..



영역구하기
지금까지 했던 문제들과 매우 매우 비슷
-> 좌표가 꼬였지만 상하를 반전해서 map을 만들어서 좌표와 배열 인덱스 계산이 편리하도록 바꿨다.
배열을 만들어서 정렬을 해도 되지만
->각 BFS마다 그 영역의 넓이가 구해지므로 영역의 개수가 총 몇개인지 미리 알 수가 없다
->배열 사이즈가 애매해진다.
-> 그냥 우선순위 큐(min heap)을 만들어서 구할때마다 큐에 넣고 마지막에 순서대로 출력
-> 이렇게 보니 그냥 힙 정렬이랑 비슷한듯
Template 사용법, STL 사용법을 익히자...
-> 매번 검색을 할 순 없잖아!
-> 나중에 정리를 싹 해야겠다.



바이러스
큐에서 delete한 시점에서 visit을 1로 설정하게 되면 아직 delete는 안 했지만 방문할 예정인 vertex를 중복해서 큐에 넣어지는 현상이 생긴다.
-> 큐에 넣을때 방문했다는 설정은 해놓자



단지번호 붙이기
너가 구현한 정렬 알고리즘을 믿지마
-> 연결리스트에 정렬을 유지하면서 추가하는 것을 해봤는데 복잡함, 그냥 qsort 사용
-> qsort를 확실하게 사용할 수 있도록 연습하자
지도 정보를 받을 때 공백을 포함해서 받는 것과 공백이 없는 입력을 받는 방법 구분하기
프린트로 디버깅한거는 제출 할 때에는 지우자



섬의 개수
find함수가 너무 괴랄하다. 
-> 좀 더 멋진 방벙을 고민해보자



결혼식
BFS를 재귀가 아니라 반복문으로 구현
-> input의 사이즈에 따라 재귀 or 반복문을 결정해야 함
-> 반복문 코드를 깔끔하게 정리하자
-> tail이 가리키는 곳이 현재 queue에 있는 마지막 vertex의 위치인지 새로운vertex가 들어갈 위치인지 미리 정하고 혼동하지 말자



토마토 7569
x,y,z 와 배열의 index를 잘 구분하자
3차원을 1차원 변환 할때 z에서의 1칸은 x*y 임을 주의하자 -> 당연한건데,,,
높이가 생긴 것 뿐인데 상당히 힘들었던거 같다



토마토 7576
큐의 head와 tail이 같으면 큐가 비었다는 것이다.
map을 initial하면서 큐에 이미 있는 토마토를 넣었고 그 것부터 delete를 진행했는데 그 때에는 덜 익은 토마토의 개수은 numofyet이 줄어들지 않는다.
-> flag를 두어 처음 delete 할때에는 numofyet이 줄어들지 않도록 함
큐에 head, tail 뿐만이 아니라 mid를 두었다,
-> vertex에서 한번 BFS를 진행했을때 답 개수르르 증가시키는 것이 아니기 때문이다.
-> 하루에 익은 토마토의 vertex를 다 큐에 넣고 그때 넣은 것이 다 delete될때 답의 개수를 증가시키는 것이다.
-> 따라서 마지막에 넣은 토마토의 vertex(tail)을 mid로 두고 앞에서 delete를 하다가 head가 mid를 만나면 답을 증가시키는 것이다.
-> 마지막 토마토를 큐에 넣고 빼면서 답 개수가 1증가 하므로 마지막에(head==tail)일때 답 개수를 하나 감소시킨다.



1,2,3더하기
규칙을 잘 찾자



보물
sort 함수 사용법
-> 3번째 인자로 함수를 설정하여 비교하는 기준을 설정할 수 있다. 여기서는 compare2가 오름 차순 정렬이다.



에디터
괜히 좀 더 빠른 방법 찾으려다가....
-> 맨 첨에 vector로 원소 중간중간에 삭제, 삽입을 사용해보려고 생각했었는데, 역시 배열기반이라 원소 중간에 데이터가 삭제, 삽입이 발생하면 느리다. -> 이론으로만 알고 있지 말고 이론으로 구현하자
->리스트로 바꿨다.
->cursor 반복자를 두어 문제의 커서 위치를 표현했다. 코드상 O(1)이지만 내부 구현이 어떨지는 찾아보자
->insert, erase때문에 정말 정말 애먹었다. 특히 erase는 반환값이 삭제한 노드의 다음노드를 가리키는 반복자였다.
->반복자에 대해 더 공부하자 + 리스트도 실험 해보자
