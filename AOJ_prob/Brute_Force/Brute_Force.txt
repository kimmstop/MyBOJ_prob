완전탐색
1. 완전탐색은 문제를 해결하느느 데 걸리는 시간은 가능한 답의 수에 비례한다. 
따라서 가능한 답의 수를 계산하고 이를 주어진 제한 시간 안에 해결 가능한지 판단한다.
만약 불가능 하다면 DP로..
2. 가능한 답의 후보를 만드는 과정을 여러 개의 선택으로 나눌 수 있다. 
3. 하나를 선택하여 답의 일부를 만들고 재귀 호출을 통해서 나머지 답 완성해 나가야한다. 
4. 기저사례를 잘 파악해야 한다. 

유형:
1. 모든 순열 만들기
N!이 모든 경우의 수 이다. 10이 넘어가면 다른 방법을 찾는것이 좋다.
c++의경우 next_permutation stl로 순열을 순서대로 생성할 수 있다. 

2. 모든 조합 만들기
nCr

3. 2^n가지 경우의 수 만들기
n개의 질문에 대해 o/x로 답을 하는 경우
비트맵을 사용하여 쉽게 표현

PICNIC(성공)
책:
중복으로 답안을 카운트 하는 것을 방지하기 위해 "특정 형태를 갖는 답안" 만 세도록 해야한다.
이 문제의 경우에는 사전순으로 가장 앞서는 답안 1개만 정답으로 카운트 하면 된다. 
각 재귀 함수의 호출에서 짝이 없는 가장 번호가 앞선 학생을 선택 한 후
그 학생번호 + 1 ~ 학생수 까지 for loop로 탐색을 하며 그 학생을 짝지어줬다.
기저 사례로 짝이 없는 학생이 없는 경우를 설정하였고 이때 1을 반환하여 답의 개수를 증가시켰다.
함수호출부분이 끝나고는 학생의 짝 정보를 알려주는 배열값을 다시 0으로 만들어서 다른 답안을 구할 수 있도록 했다. 
나:
이 방법을 고려하고 문제를 풀지는 않았지만 나는 모든 학생을 탐색하면서 그 학생과 짝을 지어줬다.
탐색을 0 ~ 학생수 로 하였기 때문에 결과적으로 사전순으로 우선인 것만 답안으로 카운트 되었다. 
함수호출이 끝나고 학생의 짝 정보를 다시 0으로 만드는 과정을 함수 Backtrack()으로 구현했고,
직전에 저장한 짝 정보를 알기위해 stack을 사용했다. 
기저 사례로는 
1. 선택한 학생의 번호가 학생수와 같을 때(모든 학생을 다 짝 지어줬을 때)
-답의 개수를 늘리고 Backtrack()
2. 선택한 학생의 번호가 이미 짝이 지어진 학생인 경우
-학생의 번호수를 증가시켜 재귀함수 호출
3. 직전에 저장한 짝 정보가 없는 경우(stack이 빈 경우)
-모든 경우를 다 탐색한 것이므로 종료


BOARDCOVER(실패)
책:
3차원 배열 block을 두어 각 블록이 어느 방향으로 보드를 cover하는지 표현했다.
1개의 칸을 채우기 위해서는 block을 이 4가지 방법 중 1 방법으로 cover헤야한다. 
Set함수를 통해서 cover 및 uncover를 둘다 구현했다. 인자로 넘겨주는 flag값으로 
보드에 flag값을 더해서 1 초과이면 검은칸에 블록을 놓은것이고 1보다 작아지면 uncover 한것이다. 
Set 함수 내에서는 covered 하는 bool 변수가 있다. 이 변수는 블록을 놓을 좌표를 탐색하는 중에
범위 밖이거나 이미 검은 칸인 경우 바로 종료하는 것이 아니라 이 변수를 false로 설정한다.
이렇게 하는 이유는 바로 종료했을 경우 나중에 블록을 uncover 할때 애초에 검은 칸이었던 블록까지 흰 블록으로 만들기 때문이다. 이를 방지 하기 위해 보드에 flag 값을 더함으로 검은칸 위에 블록이 겹쳐 있음을 의미하게 하고
나중에 flag값을 빼주어 덮은 블록을 제거할 수 있다. 

재귀 함수의 호출 구조는 비슷했으나 3차원 배열로 벡터를 표시하고 Set 함수로 cover, uncover 둘다 가능하게 하는 것은 새롭게 배웠다. 

CLOCKSYNC(성공)
책:
스위치를 누르는 순서는 중요하지 않고, 각 스위치를 몇번 누르냐가 중요하다. 
각 스위치를 누르는 횟수는 0번 에서 3번까지 이므로 4^10이 전체 경우의 수이다. 
초기에 답을 매우 큰 수로 초기화해서 탐색 중에 작은 답으로 업데이트 하는데, 답이 없는 경우 매우 큰수를 출력하게 된다. 마지막 출력시에 답이 매우 크면 -1을 출력하도록 변형하면 된다. 

나: 스위치를 누르는 순서는 상관이 없다. 0번부터 9번 스위치가 몇번씩(최대 3번씩) 눌리는지 배열을 만들었고
모든 경우의 수가 4^10이므로 완전탐색을 하여도 괜찮을 것이라 판단했다. 정답이 안나오면 -1을 출력하는 조건때문에 
오답이 나왔지만 수정 후 해결했다. 

배운점:
사고의 흐름자체는 책과 거의 비슷했으나, 구현 방식이 달랐다. 4^10을 제어변수로 두어 이 숫자를 4진수로 변형하여 가능한 모든 경우의 수 조합을 만들어서 시계를 움직였다. 
책에서는 재귀를 사용하여 0번스위치부터 차례로 누르는 횟수가 1번씩 누르도록 구현했다. 재귀를 이용할때 이전에 움직인 시계를 어떻게 초기 상태로 되돌릴지 고민되었다.
예를들어 0번스위치를 3번 누르는 것을 검사한 다음에는 0번 스위치를 0번, 1번 스위치를 1번 누르는 것을 검사해야하는데, 만약 움직인 시계가 초기화되지 않거나 되돌려지지 않으면 검사가 불가능하다고 생각했다. 맞는 말이지만 같은 스위치를 4번 누르면 원래 상태로 돌아온다는 사실을 이용해서 각 스위치를 4번 누르는 것 까지 재귀를 돌리면 0번 스위치를 4번 누르고(원래로 돌아옴) 다음으로 0번 스위치를 0번, 1번 스위치를 1번 누르는 것을 검사할 수 있다. 
재귀호출의 종료 조건은 누를 스위치가 10일때(9번까지 다 눌렀다는 것을 의미)이다. 