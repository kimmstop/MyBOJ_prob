완전탐색
1. 완전탐색은 문제를 해결하느느 데 걸리는 시간은 가능한 답의 수에 비례한다. 
따라서 가능한 답의 수를 계산하고 이를 주어진 제한 시간 안에 해결 가능한지 판단한다.
만약 불가능 하다면 DP로..
2. 가능한 답의 후보를 만드는 과정을 여러 개의 선택으로 나눌 수 있다. 
3. 하나를 선택하여 답의 일부를 만들고 재귀 호출을 통해서 나머지 답 완성해 나가야한다. 
4. 기저사례를 잘 파악해야 한다. 

PICNIC(성공)
책:
중복으로 답안을 카운트 하는 것을 방지하기 위해 "특정 형태를 갖는 답안" 만 세도록 해야한다.
이 문제의 경우에는 사전순으로 가장 앞서는 답안 1개만 정답으로 카운트 하면 된다. 
각 재귀 함수의 호출에서 짝이 없는 가장 번호가 앞선 학생을 선택 한 후
그 학생번호 + 1 ~ 학생수 까지 for loop로 탐색을 하며 그 학생을 짝지어줬다.
기저 사례로 짝이 없는 학생이 없는 경우를 설정하였고 이때 1을 반환하여 답의 개수를 증가시켰다.
함수호출부분이 끝나고는 학생의 짝 정보를 알려주는 배열값을 다시 0으로 만들어서 다른 답안을 구할 수 있도록 했다. 
나:
이 방법을 고려하고 문제를 풀지는 않았지만 나는 모든 학생을 탐색하면서 그 학생과 짝을 지어줬다.
탐색을 0 ~ 학생수 로 하였기 때문에 결과적으로 사전순으로 우선인 것만 답안으로 카운트 되었다. 
함수호출이 끝나고 학생의 짝 정보를 다시 0으로 만드는 과정을 함수 Backtrack()으로 구현했고,
직전에 저장한 짝 정보를 알기위해 stack을 사용했다. 
기저 사례로는 
1. 선택한 학생의 번호가 학생수와 같을 때(모든 학생을 다 짝 지어줬을 때)
-답의 개수를 늘리고 Backtrack()
2. 선택한 학생의 번호가 이미 짝이 지어진 학생인 경우
-학생의 번호수를 증가시켜 재귀함수 호출
3. 직전에 저장한 짝 정보가 없는 경우(stack이 빈 경우)
-모든 경우를 다 탐색한 것이므로 종료


BOARDCOVER(실패)
책:
3차원 배열 block을 두어 각 블록이 어느 방향으로 보드를 cover하는지 표현했다.
1개의 칸을 채우기 위해서는 block을 이 4가지 방법 중 1 방법으로 cover헤야한다. 
Set함수를 통해서 cover 및 uncover를 둘다 구현했다. 인자로 넘겨주는 flag값으로 
보드에 flag값을 더해서 1 초과이면 검은칸에 블록을 놓은것이고 1보다 작아지면 uncover 한것이다. 
Set 함수 내에서는 covered 하는 bool 변수가 있다. 이 변수는 블록을 놓을 좌표를 탐색하는 중에
범위 밖이거나 이미 검은 칸인 경우 바로 종료하는 것이 아니라 이 변수를 false로 설정한다.
이렇게 하는 이유는 바로 종료했을 경우 나중에 블록을 uncover 할때 애초에 검은 칸이었던 블록까지 흰 블록으로 만들기 때문이다. 이를 방지 하기 위해 보드에 flag 값을 더함으로 검은칸 위에 블록이 겹쳐 있음을 의미하게 하고
나중에 flag값을 빼주어 덮은 블록을 제거할 수 있다. 

재귀 함수의 호출 구조는 비슷했으나 3차원 배열로 벡터를 표시하고 Set 함수로 cover, uncover 둘다 가능하게 하는 것은 새롭게 배웠다. 
