완전탐색
1. 완전탐색은 문제를 해결하느느 데 걸리는 시간은 가능한 답의 수에 비례한다. 
따라서 가능한 답의 수를 계산하고 이를 주어진 제한 시간 안에 해결 가능한지 판단한다.
만약 불가능 하다면 DP로..
2. 가능한 답의 후보를 만드는 과정을 여러 개의 선택으로 나눌 수 있다. 
3. 하나를 선택하여 답의 일부를 만들고 재귀 호출을 통해서 나머지 답 완성해 나가야한다. 
4. 기저사례를 잘 파악해야 한다. 

PICNIC
책:
중복으로 답안을 카운트 하는 것을 방지하기 위해 "특정 형태를 갖는 답안" 만 세도록 해야한다.
이 문제의 경우에는 사전순으로 가장 앞서는 답안 1개만 정답으로 카운트 하면 된다. 
각 재귀 함수의 호출에서 짝이 없는 가장 번호가 앞선 학생을 선택 한 후
그 학생번호 + 1 ~ 학생수 까지 for loop로 탐색을 하며 그 학생을 짝지어줬다.
기저 사례로 짝이 없는 학생이 없는 경우를 설정하였고 이때 1을 반환하여 답의 개수를 증가시켰다.
함수호출부분이 끝나고는 학생의 짝 정보를 알려주는 배열값을 다시 0으로 만들어서 다른 답안을 구할 수 있도록 했다. 
나:
이 방법을 고려하고 문제를 풀지는 않았지만 나는 모든 학생을 탐색하면서 그 학생과 짝을 지어줬다.
탐색을 0 ~ 학생수 로 하였기 때문에 결과적으로 사전순으로 우선인 것만 답안으로 카운트 되었다. 
함수호출이 끝나고 학생의 짝 정보를 다시 0으로 만드는 과정을 함수 Backtrack()으로 구현했고,
직전에 저장한 짝 정보를 알기위해 stack을 사용했다. 
기저 사례로는 
1. 선택한 학생의 번호가 학생수와 같을 때(모든 학생을 다 짝 지어줬을 때)
-답의 개수를 늘리고 Backtrack()
2. 선택한 학생의 번호가 이미 짝이 지어진 학생인 경우
-학생의 번호수를 증가시켜 재귀함수 호출
3. 직전에 저장한 짝 정보가 없는 경우(stack이 빈 경우)
-모든 경우를 다 탐색한 것이므로 종료
